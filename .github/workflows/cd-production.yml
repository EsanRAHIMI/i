name: Deploy to Production

on:
  push:
    branches: [ main ]
  release:
    types: [ published ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: true
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Determine version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "release" ]; then
          echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        fi
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest
          type=raw,value=${{ steps.version.outputs.version }}
    
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
    
    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest
          type=raw,value=${{ steps.version.outputs.version }}
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Run Trivy vulnerability scanner on backend
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-push.outputs.backend-image }}
        format: 'sarif'
        output: 'backend-trivy-results.sarif'
    
    - name: Run Trivy vulnerability scanner on frontend
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-push.outputs.frontend-image }}
        format: 'sarif'
        output: 'frontend-trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v4
      if: always()
      with:
        sarif_file: '.'

  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    environment: production
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}
    
    - name: Add production servers to known hosts
      run: |
        echo "${{ secrets.PRODUCTION_HOSTS }}" | tr ',' '\n' | while read host; do
          ssh-keyscan -H "$host" >> ~/.ssh/known_hosts
        done
    
    - name: Deploy to production servers
      env:
        PRODUCTION_HOSTS: ${{ secrets.PRODUCTION_HOSTS }}
        PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
        BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend-image }}
        FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend-image }}
        VERSION: ${{ needs.build-and-push.outputs.version }}
      run: |
        # Deploy to each production server
        echo "$PRODUCTION_HOSTS" | tr ',' '\n' | while read host; do
          echo "Deploying to $host..."
          
          # Copy deployment files
          scp -r docker-compose.yml docker-compose.prod.yml infra/ scripts/ .env.example \
            $PRODUCTION_USER@$host:/opt/i-assistant/
          
          # Deploy on production server
          ssh $PRODUCTION_USER@$host << EOF
            cd /opt/i-assistant
            
            # Update environment for production
            if [ ! -f .env ]; then
              cp .env.example .env
              echo "ENVIRONMENT=production" >> .env
              echo "VERSION=$VERSION" >> .env
            fi
            
            # Update image tags
            sed -i "s|image: .*backend.*|image: $BACKEND_IMAGE|g" docker-compose.yml
            sed -i "s|image: .*frontend.*|image: $FRONTEND_IMAGE|g" docker-compose.yml
            
            # Run production deployment
            chmod +x scripts/deploy.sh
            ./scripts/deploy.sh --production
            
            # Verify deployment
            sleep 30
            chmod +x scripts/health-check.sh
            ./scripts/health-check.sh
          EOF
          
          echo "Deployment to $host completed"
        done
    
    - name: Run production smoke tests
      env:
        PRODUCTION_DOMAIN: ${{ secrets.PRODUCTION_DOMAIN }}
      run: |
        # Wait for load balancer to update
        sleep 60
        
        # Test main endpoints
        curl -f https://$PRODUCTION_DOMAIN/health || exit 1
        curl -f https://$PRODUCTION_DOMAIN/api/health || exit 1
        
        # Test SSL certificate
        echo | openssl s_client -servername $PRODUCTION_DOMAIN -connect $PRODUCTION_DOMAIN:443 2>/dev/null | openssl x509 -noout -dates
        
        echo "Production smoke tests passed"
    
    - name: Create deployment record
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'production',
            description: 'Production deployment of version ${{ needs.build-and-push.outputs.version }}',
            auto_merge: false
          });
    
    - name: Notify deployment success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        text: |
          üöÄ Production deployment successful!
          Version: ${{ needs.build-and-push.outputs.version }}
          Domain: https://${{ secrets.PRODUCTION_DOMAIN }}
    
    - name: Notify deployment failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        text: |
          ‚ùå Production deployment failed!
          Please check the logs and consider rollback if necessary.